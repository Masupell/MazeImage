use std::{collections::HashSet, time::{Duration, Instant}};

use macroquad::{prelude::*, rand::gen_range};

use crate::{constants::*, solver::Solver};

pub struct Maze
{
    pub grid: Vec<bool>,
    pub solver: Solver,
    pub start: usize,
    pub end: usize,
    pub started: bool
}

impl Maze
{

    pub fn new() -> Self
    {
        let grid = create_maze(None, 0.1);

        Maze
        {
            grid,
            solver: Solver::new(1378, 100),
            start: 1378,
            end: 100,
            started: false
        }
    }

    pub fn update(&mut self, timer: &mut Instant, time_stop: &Duration, block_input: bool)
    {
        
        if !block_input { self.handle_input(); }
        self.update_solver(timer, time_stop);
    }

    pub fn draw(&self)
    {
        self.draw_maze();
        self.draw_solver();
        self.draw_ends();
    }

    fn draw_maze(&self)
    {
        let cell_size = CELL_SIZE as f32;

        for (i, draw) in self.grid.iter().enumerate()
        {
            if !draw { continue; }

            let x = (i % GRID_WIDTH) as f32 * cell_size;
            let y = (i / GRID_WIDTH) as f32 * cell_size;
            draw_rectangle(x, y, cell_size, cell_size, Color::new(0.8, 0.8, 0.8, 1.0));
        }
    }

    fn handle_input(&mut self)
    {
        if is_mouse_button_released(MouseButton::Left) // Start
        {
            let pos = mouse_position();

            let x = (pos.0/CELL_SIZE as f32) as usize;
            let y = (pos.1/CELL_SIZE as f32) as usize;
            let i = y*GRID_WIDTH+x;
            self.start = i;
            self.solver.redo(self.start, self.end);
        }

        if is_mouse_button_released(MouseButton::Right) // End
        {
            let pos = mouse_position();

            let x = (pos.0/CELL_SIZE as f32) as usize;
            let y = (pos.1/CELL_SIZE as f32) as usize;
            let i = y*GRID_WIDTH+x;
            self.end = i;
            self.solver.redo(self.start, self.end);
        }

        if is_mouse_button_released(MouseButton::Middle)
        {
            let pos = mouse_position();
            
            let x = (pos.0/CELL_SIZE as f32) as usize;
            let y = (pos.1/CELL_SIZE as f32) as usize;
            let i = y*GRID_WIDTH+x;

            self.grid[i] = !self.grid[i];
        }

        if is_key_released(KeyCode::Enter)
        {
            self.solver.redo(self.start, self.end);
        }

        if is_key_released(KeyCode::Space) { self.started = !self.started; }
    }

    fn update_solver(&mut self, timer: &mut Instant, time_stop: &Duration)
    {
        if timer.elapsed() >= *time_stop && self.started
        {
            if !self.solver.found
            {
                self.solver.step(&self.grid);
            }
            else 
            {
                self.solver.reconstruction_step();
            }
            
            *timer = Instant::now();
        }
    }

    fn draw_solver(&self)
    {
        let cell_size = CELL_SIZE as f32;
        
        if !self.solver.finished
        {
            for i in 0..self.grid.len()
            {
                if self.solver.visited[i]
                {
                    let x = (i % GRID_WIDTH) as f32 * cell_size;
                    let y = (i / GRID_WIDTH) as f32 * cell_size;
                    draw_rectangle(x, y, cell_size, cell_size, Color::new(0.4, 0.8, 0.4, 1.0));
                }
            }
        }

        for i in self.solver.final_path.iter()
        {
            let x = (i % GRID_WIDTH) as f32 * cell_size;
            let y = (i / GRID_WIDTH) as f32 * cell_size;
            draw_rectangle(x, y, cell_size, cell_size, Color::new(0.4, 0.4, 0.8, 1.0));
        }
    }

    fn draw_ends(&self)
    {
        let cell_size = CELL_SIZE as f32;

        let start_x = (self.start % GRID_WIDTH) as f32 * cell_size;
        let start_y = (self.start / GRID_WIDTH) as f32 * cell_size;
        draw_rectangle(start_x, start_y, CELL_SIZE as f32, CELL_SIZE as f32, Color::new(0.8, 0.8, 0.4, 1.0));

        let end_x = (self.end % GRID_WIDTH) as f32 * cell_size;
        let end_y = (self.end / GRID_WIDTH) as f32 * cell_size;
        draw_rectangle(end_x, end_y, CELL_SIZE as f32, CELL_SIZE as f32, Color::new(0.8, 0.4, 0.4, 1.0));
    }

    pub fn regenerate_maze(&mut self, grid_input: Option<Vec<bool>>, threshold: f32)
    {
        self.grid = create_maze(grid_input, threshold);
    }
}

fn sides(pos: usize, width: usize, max: usize) -> Vec<usize>
{
    let mut neighbours = Vec::new();

    let x = pos % width;
    let y = pos / width;
    let max_y = max / width;

    if x > 0 && (y%2==1) { neighbours.push(pos - 1); }
    if x < width - 1 && (y%2==1) { neighbours.push(pos + 1); }
    if y > 0 && (x%2==1){ neighbours.push(pos - width); }
    if y < max_y-1 && (x%2==1) { neighbours.push(pos + width); }

    neighbours
}

fn random_start() -> usize
{
    let x = gen_range(0, GRID_WIDTH/2) * 2+1;
    let y = gen_range(0, GRID_HEIGHT/2) * 2+1;

    y * GRID_WIDTH + x
}

// Might keep this as hashset later, as it would be faster for the maze creation algorithm
fn get_all_walls(protected: &Vec<bool>) -> Vec<usize>
{
    let mut wall_set: HashSet<usize> = HashSet::new();

    for idx in 0..GRID_SIZE
    {
        if !protected[idx] { continue; }
        
        for ring1 in all_sides(idx, GRID_WIDTH, GRID_SIZE) //buffer around it
        {
            for ring2 in sides(ring1, GRID_WIDTH, GRID_SIZE) //actual walls
            {
                if !protected[ring2]
                {
                    wall_set.insert(ring2);
                }
            }
        }
    }

    wall_set.into_iter().collect()
}

// fn create_maze(grid_input: Option<Vec<bool>>, threshold: f32) -> Vec<bool>
// {
//     let mut protected = vec![false; GRID_SIZE];
    
//     let mut grid = if grid_input.is_some() { grid_input.unwrap() } else { vec![false; GRID_SIZE] };
    
//     for (idx, &input) in grid.iter().enumerate()
//     {
//         protected[idx] = input;
//     }
//     protected = expand_protection_zone(&protected);

//     let mut walls =  get_all_walls(&protected);

//     if walls.is_empty()
//     {
//         let start = loop
//         {
//             let s = random_start();
//             if !protected[s]
//             {
//                 break s;
//             }
//         };
//         walls = sides(start, GRID_WIDTH, GRID_SIZE);
//         grid[start] = true;
//     }
//     else 
//     {
//         let temp_copy = walls.clone();
//         for (i, &cell) in temp_copy.iter().enumerate()
//         {
//             walls.remove(i);
//             grid[cell] = true;
//             let neighbours = sides(cell, GRID_WIDTH, GRID_SIZE);
//             for &side in neighbours.iter()
//             {
//                 if !protected[side]
//                 {
//                     walls.push(side);
//                 }
//             }
//         }
//     }

//     while !walls.is_empty()
//     {        
//         let idx = gen_range(0, walls.len());
//         let cell = walls[idx];

//         let x = cell % GRID_WIDTH;
//         let y = cell / GRID_WIDTH;

//         let cell_one_idx;
//         let cell_two_idx;
//         let cell_one;
//         let cell_two;

//         if y % 2 == 1 && x % 2 == 0 // y is odd, x is even, means cells are to the left and right
//         {
//             if x == 0 || x+1 >= GRID_WIDTH { walls.remove(idx); continue; }
//             cell_one_idx = y * GRID_WIDTH + x-1;
//             cell_two_idx = y * GRID_WIDTH + x+1;
//             cell_one = grid[cell_one_idx];
//             cell_two = grid[cell_two_idx];
//         }
//         else if y % 2 == 0 && x % 2 == 1 // y is even, x is odd, means cells are up and down
//         {
//             if y == 0 || y+1 >= GRID_HEIGHT { walls.remove(idx); continue; }
//             cell_one_idx = (y-1) * GRID_WIDTH + x;
//             cell_two_idx = (y+1) * GRID_WIDTH + x;
//             cell_one = grid[cell_one_idx];
//             cell_two = grid[cell_two_idx];
//         }
//         else { walls.remove(idx); continue; }

//         if cell_one != cell_two // If only one is true (visited)
//         {
//             let unvisited = if cell_one { cell_two_idx } else { cell_one_idx };

//             if protected[unvisited] && gen_range(0.0, 1.0) >= threshold * 1.0 { walls.remove(idx); continue; }
//             grid[cell] = true;
//             grid[unvisited] = true;

//             let new_neighbours = sides(unvisited, GRID_WIDTH, GRID_SIZE);
//             for n in new_neighbours
//             {
//                 if !walls.contains(&n)
//                 {
//                     walls.push(n);
//                 }
//             }
//         }
//         walls.remove(idx);
//     }

//     grid
// }

// Version 2 (protected has connections now, but there can in rare occasions still be shorter paths, like in spirals, also a lot of single walls)
// fn create_maze(grid_input: Option<Vec<bool>>, threshold: f32) -> Vec<bool>
// {
//     let mut protected = vec![false; GRID_SIZE];
//     let mut grid = if grid_input.is_some() { grid_input.unwrap() } else { vec![false; GRID_SIZE] };
    
//     // Region tracking: 0 = no region, >0 = region ID
//     let mut regions: Vec<usize> = vec![0; GRID_SIZE];
//     let mut next_region_id = 1usize;
    
//     for (idx, &input) in grid.iter().enumerate()
//     {
//         protected[idx] = input;
//     }
    
//     protected = expand_protection_zone(&protected);
//     let mut walls = get_all_walls(&protected);
    
//     if walls.is_empty()
//     {
//         let start = loop
//         {
//             let s = random_start();
//             if !protected[s]
//             {
//                 break s;
//             }
//         };
//         walls = sides(start, GRID_WIDTH, GRID_SIZE);
//         grid[start] = true;
//     }
//     else 
//     {
//         let temp_copy = walls.clone();
//         for (i, &cell) in temp_copy.iter().enumerate()
//         {
//             walls.remove(i);
//             grid[cell] = true;
//             let neighbours = sides(cell, GRID_WIDTH, GRID_SIZE);
//             for &side in neighbours.iter()
//             {
//                 if !protected[side]
//                 {
//                     walls.push(side);
//                 }
//             }
//         }
//     }
    
//     while !walls.is_empty()
//     {        
//         let idx = gen_range(0, walls.len());
//         let cell = walls[idx];
//         let x = cell % GRID_WIDTH;
//         let y = cell / GRID_WIDTH;
//         let cell_one_idx;
//         let cell_two_idx;
//         let cell_one;
//         let cell_two;
        
//         if y % 2 == 1 && x % 2 == 0
//         {
//             if x == 0 || x+1 >= GRID_WIDTH { walls.remove(idx); continue; }
//             cell_one_idx = y * GRID_WIDTH + x-1;
//             cell_two_idx = y * GRID_WIDTH + x+1;
//             cell_one = grid[cell_one_idx];
//             cell_two = grid[cell_two_idx];
//         }
//         else if y % 2 == 0 && x % 2 == 1
//         {
//             if y == 0 || y+1 >= GRID_HEIGHT { walls.remove(idx); continue; }
//             cell_one_idx = (y-1) * GRID_WIDTH + x;
//             cell_two_idx = (y+1) * GRID_WIDTH + x;
//             cell_one = grid[cell_one_idx];
//             cell_two = grid[cell_two_idx];
//         }
//         else { walls.remove(idx); continue; }
        
//         if cell_one != cell_two
//         {
//             let (visited_idx, unvisited_idx) = if cell_one { (cell_one_idx, cell_two_idx) } else { (cell_two_idx, cell_one_idx) };
            
//             // Check if unvisited cell is protected
//             if protected[unvisited_idx]
//             {
//                 // Flood-fill to find all connected cells from visited_idx
//                 let connected_cells = flood_fill_connected(visited_idx, &grid, &protected, GRID_WIDTH, GRID_SIZE);
                
//                 // Check if ANY of the connected cells already belong to a region
//                 let has_region = connected_cells.iter().any(|&c| regions[c] != 0);
                
//                 if has_region
//                 {
//                     // This connected component already touched the protected path
//                     // Don't allow reconnection
//                     walls.remove(idx);
//                     continue;
//                 }
                
//                 // Random threshold check
//                 if gen_range(0.0, 1.0) >= threshold
//                 {
//                     walls.remove(idx);
//                     continue;
//                 }
                
//                 // Allow connection - assign new region ID to ALL connected cells
//                 for &c in connected_cells.iter()
//                 {
//                     regions[c] = next_region_id;
//                 }
//                 next_region_id += 1;
//             }
            
//             grid[cell] = true;
//             grid[unvisited_idx] = true;
            
//             let new_neighbours = sides(unvisited_idx, GRID_WIDTH, GRID_SIZE);
//             for n in new_neighbours
//             {
//                 if !walls.contains(&n)
//                 {
//                     walls.push(n);
//                 }
//             }
//         }
        
//         walls.remove(idx);
//     }
    
//     grid
// }

// // Flood-fill to find all cells connected to start_cell
// fn flood_fill_connected(start_cell: usize, grid: &Vec<bool>, protected: &Vec<bool>, grid_width: usize, grid_size: usize) -> Vec<usize>
// {
//     let mut connected = Vec::new();
//     let mut visited = vec![false; grid_size];
//     let mut stack = vec![start_cell];
    
//     while let Some(cell) = stack.pop()
//     {
//         if visited[cell] || !grid[cell] || protected[cell]
//         {
//             continue;
//         }
        
//         visited[cell] = true;
//         connected.push(cell);
        
//         // Add all neighbors - using all_sides to check all adjacent cells
//         let neighbors = all_sides(cell, grid_width, grid_size);
//         for &neighbor in neighbors.iter()
//         {
//             if !visited[neighbor] && grid[neighbor] && !protected[neighbor]
//             {
//                 stack.push(neighbor);
//             }
//         }
//     }
    
//     connected
// }

// Version 3:
fn create_maze(grid_input: Option<Vec<bool>>, threshold: f32) -> Vec<bool>
{
    let mut protected = vec![false; GRID_SIZE];
    let mut grid = if grid_input.is_some() { grid_input.unwrap() } else { vec![false; GRID_SIZE] };
    
    // Region tracking: 0 = no region, >0 = region ID
    let mut regions: Vec<usize> = vec![0; GRID_SIZE];
    let mut next_region_id = 1usize;
    
    // Track which protected cells each region has connected to: region_id -> Vec<protected_cell_idx>
    let mut region_connections: std::collections::HashMap<usize, Vec<usize>> = std::collections::HashMap::new();
    
    for (idx, &input) in grid.iter().enumerate()
    {
        protected[idx] = input;
    }
    
    protected = expand_protection_zone(&protected);
    let mut walls = get_all_walls(&protected);
    
    if walls.is_empty()
    {
        let start = loop
        {
            let s = random_start();
            if !protected[s]
            {
                break s;
            }
        };
        walls = sides(start, GRID_WIDTH, GRID_SIZE);
        grid[start] = true;
    }
    else 
    {
        let temp_copy = walls.clone();
        for (i, &cell) in temp_copy.iter().enumerate()
        {
            walls.remove(i);
            grid[cell] = true;
            let neighbours = sides(cell, GRID_WIDTH, GRID_SIZE);
            for &side in neighbours.iter()
            {
                if !protected[side]
                {
                    walls.push(side);
                }
            }
        }
    }
    
    while !walls.is_empty()
    {        
        let idx = gen_range(0, walls.len());
        let cell = walls[idx];
        let x = cell % GRID_WIDTH;
        let y = cell / GRID_WIDTH;
        let cell_one_idx;
        let cell_two_idx;
        let cell_one;
        let cell_two;
        
        if y % 2 == 1 && x % 2 == 0
        {
            if x == 0 || x+1 >= GRID_WIDTH { walls.remove(idx); continue; }
            cell_one_idx = y * GRID_WIDTH + x-1;
            cell_two_idx = y * GRID_WIDTH + x+1;
            cell_one = grid[cell_one_idx];
            cell_two = grid[cell_two_idx];
        }
        else if y % 2 == 0 && x % 2 == 1
        {
            if y == 0 || y+1 >= GRID_HEIGHT { walls.remove(idx); continue; }
            cell_one_idx = (y-1) * GRID_WIDTH + x;
            cell_two_idx = (y+1) * GRID_WIDTH + x;
            cell_one = grid[cell_one_idx];
            cell_two = grid[cell_two_idx];
        }
        else { walls.remove(idx); continue; }
        
        if cell_one != cell_two
        {
            let (visited_idx, unvisited_idx) = if cell_one { (cell_one_idx, cell_two_idx) } else { (cell_two_idx, cell_one_idx) };
            
            // Check if unvisited cell is protected
            if protected[unvisited_idx]
            {
                // Flood-fill to find all connected cells from visited_idx
                let connected_cells = flood_fill_connected(visited_idx, &grid, &protected, GRID_WIDTH, GRID_SIZE);
                
                // Check if ANY of the connected cells already belong to a region
                let existing_region = connected_cells.iter()
                    .find_map(|&c| if regions[c] != 0 { Some(regions[c]) } else { None });
                
                if let Some(region_id) = existing_region
                {
                    // This component already has a region - check if new connection would create shortcut
                    if let Some(existing_protected_connections) = region_connections.get(&region_id)
                    {
                        let mut creates_shortcut = false;
                        
                        let current_x = unvisited_idx % GRID_WIDTH;
                        let current_y = unvisited_idx / GRID_WIDTH;
                        
                        for &existing_protected_cell in existing_protected_connections.iter()
                        {
                            let existing_x = existing_protected_cell % GRID_WIDTH;
                            let existing_y = existing_protected_cell / GRID_WIDTH;
                            
                            // Calculate Manhattan distance
                            let manhattan = ((current_x as i32 - existing_x as i32).abs() + 
                                           (current_y as i32 - existing_y as i32).abs()) as usize;
                            
                            // Calculate distance along the protected path
                            let protected_distance = bfs_distance(
                                existing_protected_cell,
                                unvisited_idx,
                                &grid,
                                &protected,
                                true // traverse only protected cells
                            );
                            
                            // If Manhattan distance is much shorter than protected path distance, it's likely a shortcut
                            if let Some(p_dist) = protected_distance {
                                // If Manhattan is less than half the protected distance, probably a shortcut
                                if manhattan < p_dist / 2 {
                                    creates_shortcut = true;
                                    break;
                                }
                            }
                        }
                        
                        if creates_shortcut
                        {
                            // This would create a shortcut - don't allow
                            walls.remove(idx);
                            continue;
                        }
                        
                        // Not a shortcut - allow this additional connection
                        region_connections.get_mut(&region_id).unwrap().push(unvisited_idx);
                    }
                }
                else
                {
                    // No existing region - this is a new connection
                    // Random threshold check
                    // if gen_range(0.0, 1.0) > threshold
                    // {
                    //     walls.remove(idx);
                    //     continue;
                    // }
                    
                    // Allow connection - assign new region ID to ALL connected cells
                    for &c in connected_cells.iter()
                    {
                        regions[c] = next_region_id;
                    }
                    
                    // Record this protected cell connection
                    region_connections.insert(next_region_id, vec![unvisited_idx]);
                    
                    next_region_id += 1;
                }
            }
            
            grid[cell] = true;
            grid[unvisited_idx] = true;
            
            let new_neighbours = sides(unvisited_idx, GRID_WIDTH, GRID_SIZE);
            for n in new_neighbours
            {
                if !walls.contains(&n)
                {
                    walls.push(n);
                }
            }
        }
        
        walls.remove(idx);
    }
    
    grid
}

// Flood-fill to find all cells connected to start_cell
fn flood_fill_connected(start_cell: usize, grid: &Vec<bool>, protected: &Vec<bool>, grid_width: usize, grid_size: usize) -> Vec<usize>
{
    let mut connected = Vec::new();
    let mut visited = vec![false; grid_size];
    let mut stack = vec![start_cell];
    
    while let Some(cell) = stack.pop()
    {
        if visited[cell] || !grid[cell] || protected[cell]
        {
            continue;
        }
        
        visited[cell] = true;
        connected.push(cell);
        
        // Add all neighbors - using all_sides to check all adjacent cells
        let neighbors = all_sides(cell, grid_width, grid_size);
        for &neighbor in neighbors.iter()
        {
            if !visited[neighbor] && grid[neighbor] && !protected[neighbor]
            {
                stack.push(neighbor);
            }
        }
    }
    
    connected
}

// BFS to calculate distance between two cells
fn bfs_distance(
    start: usize,
    end: usize,
    grid: &Vec<bool>,
    protected: &Vec<bool>,
    only_protected: bool // if true, traverse only protected cells; if false, only non-protected
) -> Option<usize>
{
    use std::collections::VecDeque;
    
    let mut visited = vec![false; grid.len()];
    let mut queue = VecDeque::new();
    queue.push_back((start, 0));
    visited[start] = true;
    
    while let Some((cell, dist)) = queue.pop_front()
    {
        if cell == end {
            return Some(dist);
        }
        
        let neighbors = all_sides(cell, GRID_WIDTH, GRID_SIZE);
        for &neighbor in neighbors.iter()
        {
            if visited[neighbor] {
                continue;
            }
            
            // Check if we can traverse this cell based on mode
            let can_traverse = if only_protected {
                protected[neighbor]
            } else {
                grid[neighbor] && !protected[neighbor]
            };
            
            if can_traverse {
                visited[neighbor] = true;
                queue.push_back((neighbor, dist + 1));
            }
        }
    }
    
    None
}

fn expand_protection_zone(protected: &Vec<bool>) -> Vec<bool>
{
    let mut expanded = protected.clone();
    for idx in 0..GRID_SIZE
    {
        if !protected[idx] { continue; }

        for n in all_sides(idx, GRID_WIDTH, GRID_SIZE)
        {
            expanded[n] = true;
        }
    }
    expanded
}

fn all_sides(pos: usize, width: usize, max: usize) -> Vec<usize>
{
    let mut neighbours = Vec::new();

    let x = pos % width;
    let y = pos / width;
    let max_y = max / width;

    if x > 0 { neighbours.push(pos - 1); }
    if x < width - 1 { neighbours.push(pos + 1); }
    if y > 0 { neighbours.push(pos - width); }
    if y < max_y-1 { neighbours.push(pos + width); }

    neighbours
}